"""
Unified Canvas System for Time_Warp IDE

Implements GW BASIC screen modes with unified text and graphics rendering.
Supports keyboard input prompts and multiple display modes.
"""

import tkinter as tk
from tkinter import font
import math


class UnifiedCanvas(tk.Canvas):
    """
    Unified canvas that handles both text and graphics rendering
    with support for GW BASIC screen modes and keyboard input.
    """

    # GW BASIC Color Palettes
    CGA_PALETTE_0 = [
        "#000000", "#0000AA", "#00AA00", "#00AAAA",  # Black, Blue, Green, Cyan
        "#AA0000", "#AA00AA", "#AA5500", "#AAAAAA",  # Red, Magenta, Brown, Light Gray
        "#555555", "#5555FF", "#55FF55", "#55FFFF",  # Dark Gray, Light Blue, Light Green, Light Cyan
        "#FF5555", "#FF55FF", "#FFFF55", "#FFFFFF"   # Light Red, Light Magenta, Yellow, White
    ]

    CGA_PALETTE_1 = [
        "#000000", "#0000AA", "#00AA00", "#00AAAA",  # Black, Blue, Green, Cyan
        "#AA0000", "#AA00AA", "#AAAA00", "#AAAAAA",  # Red, Magenta, Yellow, Light Gray
        "#555555", "#5555FF", "#55FF55", "#55FFFF",  # Dark Gray, Light Blue, Light Green, Light Cyan
        "#FF5555", "#FF55FF", "#FFFF55", "#FFFFFF"   # Light Red, Light Magenta, Yellow, White
    ]

    EGA_PALETTE = [
        "#000000", "#0000AA", "#00AA00", "#00AAAA",  # 0-3
        "#AA0000", "#AA00AA", "#AA5500", "#AAAAAA",  # 4-7
        "#555555", "#5555FF", "#55FF55", "#55FFFF",  # 8-11
        "#FF5555", "#FF55FF", "#FFFF55", "#FFFFFF",  # 12-15
        "#000000", "#101010", "#202020", "#353535",  # 16-19 (extended)
        "#454545", "#555555", "#656565", "#757575",  # 20-23
        "#8A8A8A", "#9A9A9A", "#AAAAAA", "#BABABA",  # 24-27
        "#CACACA", "#DFDFDF", "#EFEFEF", "#FFFFFF"   # 28-31
    ]

    # Screen mode configurations
    SCREEN_MODES = {
        0: {
            "name": "CGA 40-column Text",
            "width": 320, "height": 200,
            "text_cols": 40, "text_rows": 25,
            "colors": 16, "palette": CGA_PALETTE_0,
            "type": "text"
        },
        1: {
            "name": "CGA 40-column Text (Alt)",
            "width": 320, "height": 200,
            "text_cols": 40, "text_rows": 25,
            "colors": 16, "palette": CGA_PALETTE_1,
            "type": "text"
        },
        2: {
            "name": "CGA 80-column Text",
            "width": 640, "height": 200,
            "text_cols": 80, "text_rows": 25,
            "colors": 16, "palette": CGA_PALETTE_0,
            "type": "text"
        },
        7: {
            "name": "EGA 320x200 Graphics",
            "width": 320, "height": 200,
            "colors": 16, "palette": EGA_PALETTE,
            "type": "graphics"
        },
        8: {
            "name": "EGA 640x200 Graphics",
            "width": 640, "height": 200,
            "colors": 16, "palette": EGA_PALETTE,
            "type": "graphics"
        },
        9: {
            "name": "EGA 640x350 Graphics",
            "width": 640, "height": 350,
            "colors": 16, "palette": EGA_PALETTE,
            "type": "graphics"
        },
        10: {
            "name": "MDA Monochrome Graphics",
            "width": 720, "height": 350,
            "colors": 2, "palette": ["#000000", "#FFFFFF"],
            "type": "graphics"
        }
    }

    def __init__(self, parent, **kwargs):
        super().__init__(parent, **kwargs)

        # Initialize screen mode
        self.current_mode = 0
        self.mode_config = self.SCREEN_MODES[self.current_mode].copy()

        # Text rendering state
        self.text_buffer = []
        self.cursor_x = 0
        self.cursor_y = 0
        self.text_color = 7  # White
        self.bg_color = 0    # Black
        self.text_items = []  # Canvas text item IDs

        # Graphics rendering state
        self.graphics_items = []
        self.pen_color = 15  # White
        self.fill_color = 0  # Black
        self.pen_down = True

        # Input handling
        self.input_prompt = ""
        self.input_callback = None
        self.input_buffer = ""
        self.input_active = False

        # Font setup
        self.font_cache = {}
        self._setup_fonts()

        # Bind events
        self.bind("<Key>", self._on_key_press)
        self.bind("<Button-1>", self._on_mouse_click)
        self.focus_set()

        # Initialize canvas
        self._update_canvas_size()
        self._clear_screen()

    def _setup_fonts(self):
        """Setup fonts for different text modes"""
        # Monospace fonts for text modes
        self.font_cache["text_40"] = font.Font(family="Courier", size=8, weight="normal")
        self.font_cache["text_80"] = font.Font(family="Courier", size=6, weight="normal")

    def _update_canvas_size(self):
        """Update canvas size based on current screen mode"""
        width = self.mode_config["width"]
        height = self.mode_config["height"]
        self.config(width=width, height=height)

    def set_screen_mode(self, mode):
        """Set the screen mode"""
        if mode not in self.SCREEN_MODES:
            raise ValueError(f"Invalid screen mode: {mode}")

        self.current_mode = mode
        self.mode_config = self.SCREEN_MODES[mode].copy()

        # Clear everything
        self._clear_screen()
        self._update_canvas_size()

        # Reset text/graphics state
        self.cursor_x = 0
        self.cursor_y = 0
        self.text_color = 7
        self.bg_color = 0
        self.pen_color = 15
        self.fill_color = 0

    def _clear_screen(self):
        """Clear the entire screen"""
        self.delete("all")
        self.text_items = []
        self.graphics_items = []

        # Fill background
        bg_color = self.mode_config["palette"][self.bg_color]
        self.create_rectangle(0, 0, self.mode_config["width"], self.mode_config["height"],
                            fill=bg_color, outline=bg_color, tags="background")

    def _get_font(self):
        """Get appropriate font for current mode"""
        if self.mode_config["type"] == "text":
            if self.mode_config["text_cols"] == 40:
                return self.font_cache["text_40"]
            else:
                return self.font_cache["text_80"]
        return self.font_cache["text_40"]

    def _get_char_size(self):
        """Get character width and height for current mode"""
        font_obj = self._get_font()
        width = font_obj.measure("W")  # Use 'W' as widest character
        height = font_obj.metrics("linespace")
        return width, height

    def write_text(self, text, x=None, y=None, color=None):
        """Write text at specified position or current cursor"""
        if x is None:
            x = self.cursor_x
        if y is None:
            y = self.cursor_y
        if color is None:
            color = self.text_color

        if self.mode_config["type"] == "text":
            self._write_text_mode(text, x, y, color)
        else:
            self._write_graphics_mode(text, x, y, color)

    def _write_text_mode(self, text, x, y, color):
        """Write text in text mode"""
        char_width, char_height = self._get_char_size()
        text_color = self.mode_config["palette"][color]

        # Handle newlines
        lines = text.split('\n')
        for i, line in enumerate(lines):
            if i > 0:
                y += 1
                x = 0

            # Wrap text if needed
            while len(line) > 0:
                cols = self.mode_config["text_cols"]
                display_text = line[:cols]
                line = line[cols:]

                pixel_x = x * char_width
                pixel_y = y * char_height

                # Create text item
                item_id = self.create_text(pixel_x, pixel_y,
                                         text=display_text,
                                         font=self._get_font(),
                                         fill=text_color,
                                         anchor="nw",
                                         tags="text")
                self.text_items.append(item_id)

                if len(line) > 0:
                    y += 1
                    x = 0

        # Update cursor position
        self.cursor_x = x + len(display_text)
        self.cursor_y = y

    def _write_graphics_mode(self, text, x, y, color):
        """Write text in graphics mode"""
        # In graphics mode, text is rendered as graphics
        text_color = self.mode_config["palette"][color]

        # Simple text rendering - could be enhanced with bitmap fonts
        item_id = self.create_text(x, y,
                                 text=text,
                                 font=self._get_font(),
                                 fill=text_color,
                                 anchor="nw",
                                 tags="graphics_text")
        self.graphics_items.append(item_id)

    def set_cursor(self, x, y):
        """Set cursor position"""
        self.cursor_x = x
        self.cursor_y = y

    def set_text_color(self, color):
        """Set text color"""
        if 0 <= color < len(self.mode_config["palette"]):
            self.text_color = color

    def set_bg_color(self, color):
        """Set background color"""
        if 0 <= color < len(self.mode_config["palette"]):
            self.bg_color = color
            # Update background
            bg_color = self.mode_config["palette"][color]
            self.itemconfig("background", fill=bg_color, outline=bg_color)

    def clear_text(self):
        """Clear all text items"""
        for item_id in self.text_items:
            self.delete(item_id)
        self.text_items = []
        self.cursor_x = 0
        self.cursor_y = 0

    def clear_graphics(self):
        """Clear all graphics items"""
        for item_id in self.graphics_items:
            self.delete(item_id)
        self.graphics_items = []

    # Graphics functions
    def draw_pixel(self, x, y, color=None):
        """Draw a single pixel"""
        if color is None:
            color = self.pen_color
        pixel_color = self.mode_config["palette"][color]
        item_id = self.create_rectangle(x, y, x+1, y+1,
                                      fill=pixel_color,
                                      outline=pixel_color,
                                      tags="pixel")
        self.graphics_items.append(item_id)

    def draw_line(self, x1, y1, x2, y2, color=None):
        """Draw a line"""
        if color is None:
            color = self.pen_color
        line_color = self.mode_config["palette"][color]
        item_id = self.create_line(x1, y1, x2, y2,
                                 fill=line_color,
                                 width=1,
                                 tags="line")
        self.graphics_items.append(item_id)

    def draw_rectangle(self, x1, y1, x2, y2, color=None, filled=False):
        """Draw a rectangle"""
        if color is None:
            color = self.pen_color
        rect_color = self.mode_config["palette"][color]

        if filled:
            fill_color = rect_color
            outline_color = rect_color
        else:
            fill_color = ""
            outline_color = rect_color

        item_id = self.create_rectangle(x1, y1, x2, y2,
                                      fill=fill_color,
                                      outline=outline_color,
                                      tags="rectangle")
        self.graphics_items.append(item_id)

    def draw_circle(self, x, y, radius, color=None, filled=False):
        """Draw a circle"""
        if color is None:
            color = self.pen_color
        circle_color = self.mode_config["palette"][color]

        x1 = x - radius
        y1 = y - radius
        x2 = x + radius
        y2 = y + radius

        if filled:
            fill_color = circle_color
            outline_color = circle_color
        else:
            fill_color = ""
            outline_color = circle_color

        item_id = self.create_oval(x1, y1, x2, y2,
                                 fill=fill_color,
                                 outline=outline_color,
                                 tags="circle")
        self.graphics_items.append(item_id)

    # Input handling
    def prompt_input(self, prompt_text, callback):
        """Display input prompt and wait for user input"""
        self.input_prompt = prompt_text
        self.input_callback = callback
        self.input_buffer = ""
        self.input_active = True

        # Display prompt
        self.write_text(f"{prompt_text} ", color=15)  # White text

    def _on_key_press(self, event):
        """Handle key press events"""
        if not self.input_active:
            return

        key = event.keysym
        char = event.char

        if key == "Return":
            # Submit input
            if self.input_callback:
                self.input_callback(self.input_buffer)
            self.input_active = False
            self.write_text("\n", color=self.text_color)

        elif key == "BackSpace":
            if self.input_buffer:
                self.input_buffer = self.input_buffer[:-1]
                # Redisplay prompt and current input
                self._redisplay_input()

        elif char and char.isprintable():
            self.input_buffer += char
            # Redisplay prompt and current input
            self._redisplay_input()

    def _redisplay_input(self):
        """Redisplay the input prompt and current buffer"""
        # Clear current input display
        self._clear_current_input_line()

        # Redisplay prompt and buffer
        self.write_text(f"{self.input_prompt} {self.input_buffer}", color=15)

    def _clear_current_input_line(self):
        """Clear the current input line"""
        # This is a simplified implementation
        # In a real implementation, you'd track the input line specifically
        pass

    def _on_mouse_click(self, event):
        """Handle mouse click events"""
        # Could be used for graphics mode interactions
        pass

    # Turtle graphics compatibility
    def turtle_forward(self, distance):
        """Move turtle forward (for compatibility)"""
        # This would need turtle state tracking
        pass

    def turtle_turn(self, angle):
        """Turn turtle (for compatibility)"""
        # This would need turtle state tracking
        pass

    # Utility methods
    def get_mode_info(self):
        """Get current mode information"""
        return self.mode_config.copy()

    def get_palette(self):
        """Get current color palette"""
    def get_palette(self):
        """Get current color palette"""
        return self.mode_config["palette"].copy()
