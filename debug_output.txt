üîß Compiling BASIC source to executable: basic_demo_compiled
üìù Step 1: Parsing BASIC source...
   Found 39 statements
   0: ('COMMENT', 'REM Simple BASIC Demo Program', 10)
   1: ('PRINT', '"JAMES BASIC Native Compiler Demo"', 20)
   2: ('PRINT', '"================================"', 30)
   3: ('PRINT', '""', 40)
   4: ('COMMENT', 'REM Variables and calculations', 50)
   5: ('LET', 'A = 5', 60)
   6: ('LET', 'B = 3', 70)
   7: ('LET', 'C = A * B', 80)
   8: ('PRINT', '"A = "; A', 90)
   9: ('PRINT', '"B = "; B', 100)
   10: ('PRINT', '"A * B = "; C', 110)
   11: ('PRINT', '""', 120)
   12: ('COMMENT', 'REM FOR loop', 130)
   13: ('PRINT', '"Counting squares:"', 140)
   14: ('FOR', 'I = 1 TO 5', 150)
   15: ('LET', 'SQUARE = I * I', 160)
   16: ('PRINT', 'I; " squared = "; SQUARE', 170)
   17: ('NEXT', 'I', 180)
   18: ('PRINT', '""', 190)
   19: ('COMMENT', 'REM Conditional logic', 200)
   20: ('LET', 'X = 10', 210)
   21: ('IF', 'X > 5 THEN PRINT "X is greater than 5"', 220)
   22: ('IF', 'X < 15 THEN PRINT "X is less than 15"', 230)
   23: ('PRINT', '""', 240)
   24: ('COMMENT', 'REM Random numbers', 250)
   25: ('PRINT', '"Random number: "; RND', 260)
   26: ('PRINT', '"Another random: "; RND', 270)
   27: ('PRINT', '""', 280)
   28: ('COMMENT', 'REM Subroutine', 290)
   29: ('PRINT', '"Calling subroutine..."', 300)
   30: ('GOSUB', '1000', 310)
   31: ('PRINT', '"Back from subroutine"', 320)
   32: ('PRINT', '""', 330)
   33: ('PRINT', '"BASIC program completed successfully!"', 340)
   34: ('END', '', 350)
   35: ('COMMENT', 'REM Subroutine', 1000)
   36: ('PRINT', '"  -> Inside subroutine"', 1010)
   37: ('PRINT', '"  -> GOSUB/RETURN works!"', 1020)
   38: ('RETURN', '', 1030)
‚öôÔ∏è  Step 2: Generating C code...
Generated C code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>

#define MAX_STRING_LEN 1024
#define MAX_VARIABLES 200
#define MAX_STACK 100

// Variable structure
typedef struct {
    char name[64];
    double value;
    char str_value[MAX_STRING_LEN];
    int is_string;
} Variable;

Variable variables[MAX_VARIABLES];
int var_count = 0;
int call_stack[MAX_STACK];
int stack_ptr = 0;

Variable* find_variable(const char* name) {
    for (int i = 0; i < var_count; i++) {
        if (strcasecmp(variables[i].name, name) == 0) {
            return &variables[i];
        }
    }
    return NULL;
}

Variable* create_variable(const char* name) {
    Variable* var = find_variable(name);
    if (var) return var;
    if (var_count < MAX_VARIABLES) {
        strcpy(variables[var_count].name, name);
        variables[var_count].value = 0.0;
        variables[var_count].str_value[0] = '\0';
        variables[var_count].is_string = 0;
        return &variables[var_count++];
    }
    return NULL;
}

void set_variable_number(const char* name, double value) {
    Variable* var = create_variable(name);
    if (var) {
        var->value = value;
        snprintf(var->str_value, MAX_STRING_LEN, "%.6g", value);
        var->is_string = 0;
    }
}

void set_variable_string(const char* name, const char* value) {
    Variable* var = create_variable(name);
    if (var) {
        strncpy(var->str_value, value, MAX_STRING_LEN - 1);
        var->str_value[MAX_STRING_LEN - 1] = '\0';
        var->is_string = 1;
        var->value = atof(value);
    }
}

double get_variable_number(const char* name) {
    Variable* var = find_variable(name);
    return var ? var->value : 0.0;
}

const char* get_variable_string(const char* name) {
    Variable* var = find_variable(name);
    if (var) {
        if (var->is_string) {
            return var->str_value;
        } else {
            static char buffer[MAX_STRING_LEN];
            snprintf(buffer, MAX_STRING_LEN, "%.6g", var->value);
            return buffer;
        }
    }
    return "";
}

double evaluate_expression(const char* expr) {
    // Simple expression evaluator for BASIC
    char buffer[MAX_STRING_LEN];
    strcpy(buffer, expr);
    
    // Handle RND function
    if (strstr(buffer, "RND")) {
        return (double)rand() / RAND_MAX;
    }
    
    // Handle simple variable references
    Variable* var = find_variable(buffer);
    if (var) {
        return var->value;
    }
    
    // Try to parse as number
    return atof(buffer);
}

int evaluate_condition(const char* expr) {
    // Simple condition evaluator
    char buffer[MAX_STRING_LEN];
    strcpy(buffer, expr);
    
    // Handle equality
    if (strstr(buffer, "=")) {
        char* eq_pos = strstr(buffer, "=");
        *eq_pos = '\0';
        char* left = buffer;
        char* right = eq_pos + 1;
        
        // Trim spaces
        while (*left == ' ') left++;
        while (*right == ' ') right++;
        
        double left_val = evaluate_expression(left);
        double right_val = evaluate_expression(right);
        return fabs(left_val - right_val) < 0.000001;
    }
    
    // Handle greater than
    if (strstr(buffer, ">")) {
        char* gt_pos = strstr(buffer, ">");
        *gt_pos = '\0';
        char* left = buffer;
        char* right = gt_pos + 1;
        double left_val = evaluate_expression(left);
        double right_val = evaluate_expression(right);
        return left_val > right_val;
    }
    
    // Handle less than
    if (strstr(buffer, "<")) {
        char* lt_pos = strstr(buffer, "<");
        *lt_pos = '\0';
        char* left = buffer;
        char* right = lt_pos + 1;
        double left_val = evaluate_expression(left);
        double right_val = evaluate_expression(right);
        return left_val < right_val;
    }
    
    // Default: evaluate as number (0 = false, non-zero = true)
    return evaluate_expression(buffer) != 0.0;
}

void print_value(const char* expr) {
    // Handle string literals
    if (expr[0] == '"') {
        char str[MAX_STRING_LEN];
        strcpy(str, expr + 1);
        if (str[strlen(str)-1] == '"') {
            str[strlen(str)-1] = '\0';
        }
        printf("%s", str);
    } else {
        // Variable or expression
        Variable* var = find_variable(expr);
        if (var) {
            if (var->is_string) {
                printf("%s", var->str_value);
            } else {
                printf("%.6g", var->value);
            }
        } else {
            printf("%.6g", evaluate_expression(expr));
        }
    }
}

int main() {
    srand(time(NULL));
    char input_buffer[MAX_STRING_LEN];
    int pc = 0;
    int program_size = 39;

    while (pc < program_size) {
        switch (pc) {
            case 0: // Line 10
                // REM Simple BASIC Demo Program
                pc++;
                break;
            case 1: // Line 20
                print_value("\"JAMES BASIC Native Compiler Demo\"");
                printf("\n");
                pc++;
                break;
            case 2: // Line 30
                print_value("\"================================\"");
                printf("\n");
                pc++;
                break;
            case 3: // Line 40
                print_value("\"\"");
                printf("\n");
                pc++;
                break;
            case 4: // Line 50
                // REM Variables and calculations
                pc++;
                break;
            case 5: // Line 60
                set_variable_number("A", evaluate_expression("5"));
                pc++;
                break;
            case 6: // Line 70
                set_variable_number("B", evaluate_expression("3"));
                pc++;
                break;
            case 7: // Line 80
                set_variable_number("C", evaluate_expression("A * B"));
                pc++;
                break;
            case 8: // Line 90
                print_value("\"A = \"");
                print_value("A");
                printf("\n");
                pc++;
                break;
            case 9: // Line 100
                print_value("\"B = \"");
                print_value("B");
                printf("\n");
                pc++;
                break;
            case 10: // Line 110
                print_value("\"A * B = \"");
                print_value("C");
                printf("\n");
                pc++;
                break;
            case 11: // Line 120
                print_value("\"\"");
                printf("\n");
                pc++;
                break;
            case 12: // Line 130
                // REM FOR loop
                pc++;
                break;
            case 13: // Line 140
                print_value("\"Counting squares:\"");
                printf("\n");
                pc++;
                break;
            case 14: // Line 150
                set_variable_number("I", evaluate_expression("1"));
                // FOR loop: I = 1 TO 5 STEP 1
                pc++;
                break;
            case 15: // Line 160
                set_variable_number("SQUARE", evaluate_expression("I * I"));
                pc++;
                break;
            case 16: // Line 170
                print_value("I");
                print_value("\" squared = \"");
                print_value("SQUARE");
                printf("\n");
                pc++;
                break;
            case 17: // Line 180
                set_variable_number("I", get_variable_number("I") + evaluate_expression("1"));
                if (get_variable_number("I") <= evaluate_expression("5")) {
                    pc = 14; // Jump back to FOR (no -1 needed because we skip pc++)
                    break; // Skip the pc++ at the end
                }
                pc++;
                break;
            case 18: // Line 190
                print_value("\"\"");
                printf("\n");
                pc++;
                break;
            case 19: // Line 200
                // REM Conditional logic
                pc++;
                break;
            case 20: // Line 210
                set_variable_number("X", evaluate_expression("10"));
                pc++;
                break;
            case 21: // Line 220
                if (evaluate_condition("X > 5")) {
                    // THEN: PRINT "X is greater than 5"
                }
                pc++;
                break;
            case 22: // Line 230
                if (evaluate_condition("X < 15")) {
                    // THEN: PRINT "X is less than 15"
                }
                pc++;
                break;
            case 23: // Line 240
                print_value("\"\"");
                printf("\n");
                pc++;
                break;
            case 24: // Line 250
                // REM Random numbers
                pc++;
                break;
            case 25: // Line 260
                print_value("\"Random number: \"");
                print_value("RND");
                printf("\n");
                pc++;
                break;
            case 26: // Line 270
                print_value("\"Another random: \"");
                print_value("RND");
                printf("\n");
                pc++;
                break;
            case 27: // Line 280
                print_value("\"\"");
                printf("\n");
                pc++;
                break;
            case 28: // Line 290
                // REM Subroutine
                pc++;
                break;
            case 29: // Line 300
                print_value("\"Calling subroutine...\"");
                printf("\n");
                pc++;
                break;
            case 30: // Line 310
                call_stack[stack_ptr++] = pc;
                pc = 35 - 1;
                pc++;
                break;
            case 31: // Line 320
                print_value("\"Back from subroutine\"");
                printf("\n");
                pc++;
                break;
            case 32: // Line 330
                print_value("\"\"");
                printf("\n");
                pc++;
                break;
            case 33: // Line 340
                print_value("\"BASIC program completed successfully!\"");
                printf("\n");
                pc++;
                break;
            case 34: // Line 350
                return 0;
                pc++;
                break;
            case 35: // Line 1000
                // REM Subroutine
                pc++;
                break;
            case 36: // Line 1010
                print_value("\"  -> Inside subroutine\"");
                printf("\n");
                pc++;
                break;
            case 37: // Line 1020
                print_value("\"  -> GOSUB/RETURN works!\"");
                printf("\n");
                pc++;
                break;
            case 38: // Line 1030
                if (stack_ptr > 0) {
                    pc = call_stack[--stack_ptr];
                }
                pc++;
                break;
            default:
                pc++;
                break;
        }
    }
    return 0;
}
üî® Step 3: Building executable...
   C compilation successful
‚úÖ Compilation successful: basic_demo_compiled
